---
title: "JVM之类加载机制"
catalog: true
date: 2019-05-21 17:30:11
subtitle: "This is about JVM."
header-img: "Demo.png"
tags:
- JVM
- 类加载机制
catagories:
- JVM
---

# JVM之类加载机制

## 1.类加载机制

![20160504235346278](/Users/chriswu/Desktop/Java%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%A0%88/pic/20160504235346278.png)

解析阶段顺序不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的运行时绑定。

类加载机制的第一个阶段加载做的工作有：

1、通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。而获取的方式，可以通过jar包、war包、网络中获取、JSP文件生成等方式。

2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。这里只是转化了数据结构，并未合并数据。（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）

3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。这个Class对象并没有规定是在Java堆内存中，它比较特殊，虽为对象，但存放在方法区中。



> 通过子类来引用父类的静态字段，不会导致子类初始化



## 2.双亲委派模型

![20160507202024030](/Users/chriswu/Desktop/Java%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%A0%88/pic/20160507202024030.png)



### 1.双亲委派机制的源码实现

主要体现在ClassLoader的loadClass()方法中，思路很简单：先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，调用自己的findClass()方法进行加载。

#### 

## 3.Tomcat 的类加载机制

![746039A4-2417-4B64-93FE-378B57431583](/Users/chriswu/Desktop/Java%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%A0%88/pic/746039A4-2417-4B64-93FE-378B57431583.png)




---
title: "JVM之内部结构"
catalog: true
date: 2019-05-19 23:10:41
subtitle: "This is about JVM."
header-img: "Demo.png"
tags:
- JVM
- 内部结构
catagories:
- JVM
---

# JVM之内部结构

![EE063756-C87C-4E22-8F76-23C31CFB6D45](/Users/chriswu/Desktop/Java开发技术栈/pic/EE063756-C87C-4E22-8F76-23C31CFB6D45.png)

## 1.程序计数器

程序计数器是线程私有的区域，每个线程的计数器，记录当前执行到那个指令。占用的内存空间小，可以把它看成是当前线程所执行的字节码的行号指示器。如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是Native方法，这个计数器的值为空（Undefined）。

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

> 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。



## 2.虚拟机栈

其生命周期与线程相同。本质上来讲，就是个栈。里面存放的元素叫栈帧，里面存放的是一个函数的上下文，具体存放的是执行的函数的一些数据。执行的函数需要的数据无非就是局部变量表（保存函数内部的变量）、操作数栈（执行引擎计算时需要），方法出口等等。

执行引擎每调用一个函数时，就为这个函数创建一个栈帧，并加入虚拟机栈。换个角度理解，每个函数从调用到执行结束，其实是对应一个栈帧的入栈和出栈。

这个区域可能出现的两种异常：一种是**StackOverflowError**，当前线程请求的栈深度大于虚拟机所允许的深度时，会抛出这个异常。制造这种异常很简单：**将一个函数反复递归自己，最终会出现栈溢出错误**（StackOverflowError）。另一种异常是**OutOfMemoryError**异常，当虚拟机栈可以动态扩展时（当前大部分虚拟机都可以），如果无法申请足够多的内存就会抛出OutOfMemoryError



## 3.本地方法栈

本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于**虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务**。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常

> 有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一



## 4.堆

堆可以说是虚拟机中最大一块内存了。它是所有线程所共享的内存区域，**几乎所有的实例对象**都是在这块区域中存放。当然，睡着JIT编译器的发展，所有对象在堆上分配渐渐变得不那么“绝对”了。

Java堆是垃圾收集器管理的主要区域。由于现在的收集器基本上采用的都是分代收集算法，所有Java堆可以细分为：新生代和老年代。在细致分就是把新生代分为：Eden空间、From Survivor空间、To Survivor空间。当堆无法再扩展时，会抛出OutOfMemoryError异常。



## 5.方法区

方法区存放的是类信息、常量、静态变量等。方法区是各个线程共享区域，很容易理解，我们在写Java代码时，每个线程度可以访问同一个类的静态变量对象。**由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难**。另外，**对这块区域主要是针对常量池回收，值得注意的是JDK1.7已经把常量池转移到堆里面了**。同样，当方法区无法满足内存分配需求时，会抛出OutOfMemoryError
---
title: "Java基础之细碎知识点归纳"
catalog: true
date: 2019-05-01 21:44:00
subtitle: "This is about java."
header-img: "Demo.png"
tags:
- Java 基础
catagories:
- Java 基础
---

# Java基础之细碎知识点归纳

## 1.Object类的九大方法

1．clone方法

保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

2．getClass方法
final方法，获得运行时类型。

3．toString方法
该方法用得比较多，一般子类都有覆盖。

4．finalize方法
该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

5．equals方法
该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

6．hashCode方法
该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

7．wait方法
wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

（1）其他线程调用了该对象的notify方法。

（2）其他线程调用了该对象的notifyAll方法。

（3）其他线程调用了interrupt中断该线程。

（4）时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

8．notify方法
该方法唤醒在该对象上等待的某个线程。

9．notifyAll方法

该方法唤醒在该对象上等待的所有线程。

## 2.==和equal（）的区别

1. 基本数据类型。 
   byte,short,char,int,long,float,double,boolean 他们之间的比较，应用双等号（==）,比较的是他们的值。
2. 复合数据类型(类) 
   当他们用（==）进行比较的时候，比较的是他们在JVM中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为也是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。
3. String的equal（） 
   (1)String类中的equals首先比较地址，如果是同一个对象的引用，可知对象相等，返回true。 
   (2)若果不是同一个对象，equals方法挨个比较两个字符串对象内的字符，只有完全相等才返回true，否则返回false。

## 3.String、StringBuffer、StringBuilder的区别

1. String 字符串常量（对象不可变，线程安全）private final char value[]; 
2. StringBuffer 字符串变量（线程安全） 
3. StringBuilder 字符串变量（非线程安全） char[] value; 
4. 如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 
5. 在大部分情况下 StringBuilder > StringBuffer> String

## 4.final, finally, finalize的区别

1. final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
2. finally是异常处理语句结构的一部分，表示总是执行。
3. finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

## 5.Overload和Override的区别

1. 方法的重写Overriding和重载Overloading是Java多态性的不同表现。
2. 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
3. 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。

## 6.抽象类和接口的区别

一个类只能继承一个类（抽象类），但是可以实现多个接口。 

1. 接口可以多继承，抽象类不行 
2. 抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。 
3. 接口中基本数据类型为public static 而抽类象不是，是普通变量类型。 
4. 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 
5. 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。

## 7.值传递/引用传递

在Java中所有的参数传递，不管基本类型还是引用类型，**都是值传递**，或者说是副本传递。

只是在传递过程中：

1. 如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。
2. 如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。